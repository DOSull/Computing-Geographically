{
  "hash": "f2dd97d8f0797b911a6fa810b517e5c6",
  "result": {
    "markdown": "---\ntitle: \"Figure 4.3: Many Springfields\"\ncategories: \n  - figures\n  - code\n  - extras\nexecute: \n  cache: true\n  freeze: auto\n---\n\n\nMany of the data preparation steps for this figure were initially carried out in QGIS. Here they have been implemented in _R_ only.\n\nTo understand why this version is different from the published figure, read on...\n\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-1_157ca09d3c045a14edc735b9e86021b3'}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tmap)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(units)\n\nsf_use_s2(FALSE)\n```\n:::\n\n\n## Get data\nThe 'Springfields' data set was obtained using the following code (shown here but not run) to query the [Nominatim geocoder](https://nominatim.openstreetmap.org/ui/search.html).\n\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-2_3cd1959a2414c090fc3780fff3d5d4ad'}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(stringr)\n\nquery <- \"https://nominatim.openstreetmap.org/search\"\nplace <- \"Springfield\"\nexcluded_places <- \"\"\n\nresult <- NULL\ngot_new_results <- TRUE\nn_results <- 0\nmax_n <- 1000\n\nwhile (n_results < max_n & got_new_results) {\n  url <- str_flatten(c(\n    str_glue(\"{query}?q={place}&\"),\n    \"polygon_geojson=1&limit=50&format=geojson&\",\n    str_glue(\"exclude_place_ids={excluded_places}\")\n  ))\n  download.file(url, \"result.geojson\", quiet = TRUE, method = \"auto\")\n  next_result <- st_read(\"result.geojson\")\n  got_new_results <- dim(next_result)[1] > 0\n  if (is.null(result)) {\n    result <- next_result\n  } else {\n    result <- bind_rows(result, next_result)\n  }\n  n_results <- dim(result)[1]\n  excluded_places <- str_flatten(result$place_id, collapse = \",\")\n  Sys.sleep(1)\n}\n\nresult %>% \n  st_centroid() %>% \n  st_write(str_glue(\"all-results-{place}.geojson\"))\n```\n:::\n\n\n## Make a map\nOK, with that done, we can make a map. The degree of difficulty is much increased by choosing a [Briesemeister projection](https://www.map-projections.net/single-view/briesemeister-v2). We choose projections like this one not because they are easy, but because they are hard (something like that...). Anyway the published map is actually an oblique [Hammer-Aitoff projection](https://en.wikipedia.org/wiki/Aitoff_projection) based on this `proj` string.\n\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-3_6acf8f4f4e37c8edcf9b34c151c00306'}\n\n```{.r .cell-code}\nbries <- \"+proj=ob_tran +o_proj=hammer +o_lat_p=45 +o_lon_p=-10 +lon_0=0\"\n```\n:::\n\n\nI'll explain why this is only an *approximate* Briesemeister projection [later](#as-it-turns-out).\n\n### Dealing with that weird projection\nA world 'disc' for the background. Make this by buffering a point and stretching it to an ellipse with the projection extent (this has been estimated to the nearest 10m).\n\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-4_b6101695084705298866df887cdc2edd'}\n\n```{.r .cell-code}\ndisc <- st_point(c(0, 0)) %>%\n  st_buffer(1, nQuadSegs = 90)\ndisc <- disc * matrix(c(18040100, 0, 0, 9020050), 2, 2)\ndisc <- disc %>%\n  st_sfc() %>%\n  st_sf(crs = bries)\n```\n:::\n\n\nThe world countries must be cut at the Briesemeister 'cut line' which is where there is a break in the projection, to avoid anomalies when places are projected that cross the line. We figured out where this line is in other work...\n\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-5_930271c3ebd5446ea2a9e2a5cb6ac8d0'}\n\n```{.r .cell-code}\ndata(\"World\")\n\ncut_line <- st_read(\"briesemeister-cut.geojson\") %>%\n  st_buffer(0.002)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ndist is assumed to be in decimal degrees (arc_degrees).\n```\n:::\n\n```{.r .cell-code}\nworld <- World %>%\n  st_difference(cut_line) %>%\n  st_transform(bries) %>%\n  select(-(1:15)) # get rid of variables we have no need for\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nalthough coordinates are longitude/latitude, st_difference assumes that they\nare planar\n```\n:::\n:::\n\n\n### Make a graticule \nA graticule - here we assemble this as linestrings (with many points) because projection of `tm_graticules` output can be problematic, especially if the projection has cuts other than at &pm;180&deg; longitude (and even then it can have issues), or as in this case is in any way unusual.\n\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-6_c96572f83b9d3fc85974b59b64acf375'}\n\n```{.r .cell-code  code-fold=\"true\"}\nget_meridian <- function(longitude) {\n  st_linestring(matrix(cbind(longitude, seq(-90, 90, 1)),\n                       ncol = 2, byrow = FALSE)) %>%\n    st_sfc(crs = 4326)\n}\n\nget_meridians <- function(spacing = 15) {\n  g <- c()\n  for (lon in seq(-180, 180 - spacing, spacing)) {\n    g <- c(g, get_meridian(longitude = lon))\n  }\n  g\n}\n\nget_parallel <- function(latitude) {\n  st_linestring(matrix(cbind(seq(-180, 180, 1), latitude),\n                       ncol = 2, byrow = FALSE)) %>%\n    st_sfc(crs = 4326)\n}\n\nget_parallels <- function(spacing = 15) {\n  g <- c()\n  for (lat in seq(-90 + spacing, 90 - spacing, spacing)) {\n    g <- c(g, get_parallel(latitude = lat))\n  }\n  g\n}\n\ngraticule <- c(get_meridians(), get_parallels()) %>%\n  st_sfc(crs = 4326) %>%\n  # again it must be cut at the Briesemeister breakline\n  st_difference(cut_line) %>%\n  st_sfc() %>%\n  st_sf() %>%\n  st_transform(bries)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nalthough coordinates are longitude/latitude, st_difference assumes that they\nare planar\n```\n:::\n:::\n\n\n### As it turns out\nThe published map is really not in the Briesemeister proper, which is a _stretched_ version of an oblique Hammer-Aitoff projection. See\n\n> Briesemeister W. 1953. A new oblique equal-area projection. *Geographical Review* **43**(2) 260&ndash;261. doi: [10.2307/211940](https://dx.doi.org/10.2307/211940).\n\nfor details. So let's also do that here (this really is bonus material). We could use the `+proj=affine` transformation with appropriate settings, but I've had issues getting `GDAL` and `tmap` to cooperate with pipeline projected data. Instead, we'll just use the weird matrix multiplication of geometries trick that `sf` allows to apply the required stretch, and not update the CRS information&mdash;thus making these data layers useless for almost any other purpose.\n\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-7_8ab9050c75ddce106d9a3fdb51f6905a'}\n\n```{.r .cell-code}\nstretch_mat <- matrix(c(7/8, 0, 0, 8/7), 2, 2)\ndisc <- disc %>%\n  mutate(geometry = geometry * stretch_mat)\nworld <- world %>%\n  mutate(geometry = geometry * stretch_mat)\ngraticule <- graticule %>%\n  mutate(geometry = geometry * stretch_mat)\n```\n:::\n\n\nFor what it's worth, all these shenanigans are a good example of why more flexibility in the projection architectures of contemporary platforms would be welcome, something discussed in [Chapter 3](../chap3/index.qmd).\n\n## Yeah, OK, _now_ make a map of all those Springfields\n\n\n::: {.cell fig.size='[8,4]' hash='fig4-03-springfields_cache/html/unnamed-chunk-8_d0017ad8fabd02189cbc82cb51097a06'}\n\n```{.r .cell-code}\nspringfields <- st_read(\"all-results-Springfield.geojson\") %>%\n  st_transform(bries) %>%\n  mutate(geometry = geometry * stretch_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `all-results-Springfield' from data source \n  `/Users/osullid3/Documents/code/computing-geographically/chapters/chap4/all-results-Springfield.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 814 features and 9 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -123.022 ymin: -43.33784 xmax: 176.228 ymax: 67.28429\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\ntm_shape(disc) + \n  tm_fill(col = \"#eeeeee\") + \n  tm_shape(world) + \n  tm_fill(col = \"white\") +\n  tm_shape(springfields) +\n  tm_dots(col = \"red\", size = 0.15, alpha = 0.15) +\n  tm_shape(graticule) +\n  tm_lines(col = \"gray\", lwd = 0.5) +\n  tm_layout(frame = FALSE)\n```\n\n::: {.cell-output-display}\n![](fig4-03-springfields_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='fig4-03-springfields_cache/html/unnamed-chunk-9_ef85cf2266026a966f14c23f1571c1ed'}\n\n```{.r .cell-code  code-fold=\"true\"}\n# License (MIT)\n#\n# Copyright (c) 2023 David O'Sullivan\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation\n# files (the \"Software\"), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to  permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}