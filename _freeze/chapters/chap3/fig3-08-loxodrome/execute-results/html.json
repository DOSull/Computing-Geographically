{
  "hash": "a21f54320e0fda3de8d58fa7bbd17e7c",
  "result": {
    "markdown": "---\ntitle: \"Figure 3.8: A loxodrome on the sphere and projected\"\ncategories: \n  - figures\n  - code\nexecute: \n  cache: true\n  freeze: auto\n---\n\n\nThe figure produced below extends to &pm;89&deg; which makes the point even more clearly, but doesn't give a nice square Mercator projected map. See also [Jason Davies' page about loxodromes](https://www.jasondavies.com/maps/loxodrome/) for more on this, including a couple of figures that probably on some level inspired mine. Indeed, Jason Davies' pages include some gems for exploring the variety of global projections. See, for example, [Map Projection Transitions](https://www.jasondavies.com/maps/transition/).\n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-1_6978d92aa3f202604ba370e70c06b874'}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(sf)\nlibrary(tmap)\nlibrary(smoothr) # this is for interpolating along lines\n```\n:::\n\n\nThis process is pretty complicated to do in _R_, so we need a bunch of helper functions. First, it is the default for `sf` now, but just to make the point, we intially use S2 mode, so that when we clip data with a hemisphere it does it properly.\n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-2_615ba2823e885ca6675ab89f960ee391'}\n\n```{.r .cell-code}\nsf_use_s2(TRUE)\n```\n:::\n\n\nAlso, define an [orthographic projection](https://proj.org/en/9.3/operations/projections/ortho.html) for the globe view.\n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-3_7230ef0636543e9da06fb3353518abcb'}\n\n```{.r .cell-code}\northo_proj <- \"+proj=ortho lon_0=0 lat_0=40\"\n```\n:::\n\n\n## Make a hemisphere\nMake a hemisphere for the globe view, and apply it to the built-in `World` dataset that ships with `tmap`.\n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-4_591fd23a0c93988e85be4d47fb000324'}\n\n```{.r .cell-code}\nhemisphere <- st_point(c(0, 0)) %>%\n  st_buffer(6356752) %>%\n  st_sfc(crs = ortho_proj) %>%\n  densify() %>%\n  st_transform(4326)\n\ndata(\"World\")\nworld_o <- World %>%\n  st_intersection(hemisphere) %>%\n  st_transform(ortho_proj) %>%\n  filter(st_is_empty(geometry) == FALSE)\n```\n:::\n\n\n## Helper functions for coordinate transformations\nNext, convenience 'helper' functions for converting coordinate pairs between projections, and converting degrees to radians. By default it will convert longitude-latitude to Mercator.\n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-5_b82a921e7382ff138113297db9cda13e'}\n\n```{.r .cell-code}\nx1y1_to_x2y2 <- function(coords, crs1 = 4326, crs2 = \"+proj=merc\") {\n  coords %>% st_point() %>%\n    st_sfc(crs = crs1) %>%\n    st_transform(crs2) %>%\n    st_coordinates() %>%\n    c()\n}\n\nget_radians <- function(d) {\n  d * pi / 180\n} \n```\n:::\n\n\n## Making a loxodrome\nThe next function makes a loxodrome line of equal bearing, starting from 89&deg;S 180&deg;E, and ending when it hits latitude 89&deg;N (latitude range is determined by the `lat` parameter). The calculations are done in Mercator coordinates, since it is in this projection that a loxodrome is a straight line.\n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-6_ca1b17c6af468e13afe46359220659ad'}\n\n```{.r .cell-code}\nget_loxodrome <- function(lat = -89, bearing = 85, n = 100) {\n  transects <- c() # empty vector for the west to east transects\n  pt <- c(-180, lat)\n\n  # we keep going until we hit the latitude at lat North\n  while(TRUE && pt[2] < -lat) {\n    p1 <- x1y1_to_x2y2(pt) # convert to Mercator\n    # get the point at +180, ie 2 * pi radians in Mercator\n    p2 <- c(-p1[1],         \n            p1[2] + tan(get_radians(90 - bearing)) * -2 * p1[1])\n    # the line is a densified version of this\n    transect <- st_linestring(matrix(c(p1, p2), 2, 2, byrow = TRUE)) %>%\n      st_sfc(crs = \"+proj=merc\") %>%\n      densify(n) # the densification step (provided by smoothr)\n    transects <- c(transects, transect)\n    # reset p1 to 'the other side' of the Mercator space i.e. -180\n    p1 <- p2\n    pt <- x1y1_to_x2y2(p1, crs1 = \"+proj=merc\", crs2 = 4326)\n    pt[1] <- -180\n  }\n  # transects need tidying so they extend equally far N and S of equator\n  # max y coordinate should be the inverse of the minimum y coordinate\n  ymax <- x1y1_to_x2y2(c(0, -lat))[2]\n  # apply this limit to the points along the last transect from west to east\n  n_transects <- length(lines)\n  # convert the last transect to a set of points, to apply this limit\n  pts <- transects[[n_transects]] %>%\n    st_cast(\"MULTIPOINT\") %>%\n    st_coordinates()\n  pts <- pts[pts[, 2] <= ymax, 1:2]\n  # and then convert back to a linestring\n  transects[[n_transects]] <- pts %>%\n    matrix(ncol = 2) %>%\n    st_linestring()\n  # finally convert to lon-lat i.e. EPSG 4326\n  transects %>% st_sfc(crs = \"+proj=merc\") %>%\n    st_as_sf() %>%\n    st_transform(4326)\n}\n```\n:::\n\n\n## Now make the figure!\n### Assemble the layers\nMake a loxodrome and clip the world to the chosen latitude limits. To apply rectangular projection based limits we have to switch to planar geometry in `sf`. We have to do this because we can't show the whole world in Mercator... \n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-7_daf634642d63cab396bd32617af16054'}\n\n```{.r .cell-code}\nlox <- get_loxodrome() \nlox_o <- lox %>%\n  st_intersection(hemisphere)\n\nsf_use_s2(FALSE)\n\nmercator_limits <- st_polygon(list(\n  matrix(c(-180, -89, 180, -89, 180, 89, -180, 89, -180, -89),\n  ncol = 2, byrow = TRUE))) %>%\n  st_sfc(crs = 4326) %>%\n  st_as_sf()\n\nworld_m <- World %>% \n  st_intersection(mercator_limits) %>%\n  st_transform(\"+proj=merc\") %>%\n  filter(st_is_empty(geometry) == FALSE)\n\nlox_m <- lox %>%\n  st_intersection(mercator_limits)\n```\n:::\n\n\n### Put them together\nAnd finally make the maps. (In the version in the book I handmade the graticule, not realising that there was a `tm_graticules` function in `tmap`...).\n\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-8_e3b3ce176d7cf2c6a582e3ba2e284206'}\n\n```{.r .cell-code}\nm1 <- tm_shape(world_o) + \n  tm_fill(col = \"lightgray\") +\n  tm_graticules(x = seq(-180, 165, 15), y = seq(-75, 75, 15), \n                col = \"gray\", lwd = 0.5, labels.show = FALSE) +\n  tm_shape(lox_o) + \n  tm_lines(col = \"black\") +\n  tm_layout(frame = FALSE)\n\nm2 <- tm_shape(world_m, bbox = mercator_limits) + \n  tm_fill(col = \"lightgray\") +\n  tm_graticules(x = seq(-180, 165, 15), y = seq(-75, 75, 15), \n                col = \"gray\", lwd = 0.5, labels.show = FALSE) +\n  tm_shape(lox_m) + \n  tm_lines(col = \"black\") +\n  tm_layout(frame = FALSE)\n\ntmap_arrange(m1, m2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](fig3-08-loxodrome_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='fig3-08-loxodrome_cache/html/unnamed-chunk-9_5b978a15a8a71a334b9fc3eea4435757'}\n\n```{.r .cell-code  code-fold=\"true\"}\n# License (MIT)\n#\n# Copyright (c) 2023 David O'Sullivan\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation\n# files (the \"Software\"), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to  permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}