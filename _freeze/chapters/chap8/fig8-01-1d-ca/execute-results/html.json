{
  "hash": "fd82c46dda37caac725a2715f315a05c",
  "result": {
    "markdown": "---\ntitle: \"Figures 8.1 and 8.2: One-dimensional CA\"\ncategories: \n  - figures\n  - code\n  - R\nexecute: \n  cache: true\n  freeze: auto\nknitr:\n  opts_chunk: \n    warning: false\n    message: false\n---\n\n\nAgain, the examples in the book were made using a NetLogo model based on [this one in the NetLogo model library](http://ccl.northwestern.edu/netlogo/models/CA1DElementary). This page provides _R_ code instead.\n\n## Model code\nThe 1D elementary CA model code is in the block below. It returns a matrix of cell states, with each system state a row in the matrix.\n\nThe key function is `one_d_ca(rule, n, density, t)`, which returns a `t` $\\times$ `n` matrix, with initial density of 1's given by the `density` parameter, and the update rule being Wolfram code `rule`.\n\n\n::: {.cell hash='fig8-01-1d-ca_cache/html/unnamed-chunk-1_0d2bc197f016ee962793e930e521e9bf'}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(dplyr)\n\n# initialise random state, specified size and density\ninit_state <- function(n = 50, density = 0.5) {\n  as.numeric(runif(n) < density)\n}\n\n# pre- and post-fix the last and first elements of the state\nwrap_state <- function(x) {\n  c(tail(x, 1), x, x[1])\n}\n\n# binary vector to decimal integer (most significant bits first)\nas_decimal <- function(b) {\n  sum((2 ^ ((length(b) - 1):0)) * b)\n}\n\n# convert decimal integer to vector of bits (most significant first)\nas_binary <- function(n, n_bits = 8) {\n  result <- c()\n  for (i in 1:n_bits) {\n    result <- c(n %% 2, result)\n    n <- n %/% 2\n  }\n  result\n}\n\nrule_description <- function(rule_num) {\n  paste(rule_num, \n        paste(as_binary(rule_num), collapse = \"\"), \n        sep = \": \")\n}\n\n# takes a matrix of CA states (each row a timestep) and appends\n# a new row for the next system state\ngeneration <- function(states, rule) {\n  state <- tail(states, 1) %>% c()\n  w_state <- wrap_state(state)\n  result <- c()\n  for (i in 1:length(state)) {\n    nbhd <- w_state[seq(i, i + 2)]\n    result <- c(result, rule[as_decimal(nbhd) + 1])\n  }\n  matrix(c(states %>% t() %>% c(), result), nc = ncol(states), byrow = TRUE)\n}\n\n# generate a matrix of cell states where each row is the system state\none_d_ca <- function(rule = 30, n = 64, density = 0.5, t = 192) {\n  s <- init_state(n, density)\n  ss <- matrix(s, nr = 1)\n  for (i in 2:t) {\n    ss <- generation(ss, rev(as_binary(rule)))\n  }\n  ss\n}\n```\n:::\n\n\n## Making plots\n### Figure 8.2\nThe matrix format is convenient for computation, and fine for plotting a single model result but that has to be converted to a dataframe to be plotted using `ggplot2`. So here is the pure _R_ version of Figure 8.2:\n\n\n::: {.cell hash='fig8-01-1d-ca_cache/html/unnamed-chunk-2_97dd6763d9983ec7fbcc475a32f49fb9'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(reshape2)\n\none_d_ca(rule = 110) %>%\n  reshape2::melt(c(\"t\", \"x\"), value.name = \"state\") %>%\n  mutate(state = as.logical(state)) %>%\n  ggplot() +\n    geom_raster(aes(x = t, y = x, fill = state)) + \n    scale_fill_brewer(palette = \"Paired\") +\n    coord_equal() +\n    guides(fill = \"none\") +\n    theme_void()\n```\n\n::: {.cell-output-display}\n![](fig8-01-1d-ca_files/figure-html/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n\n### Figure 8.1\nAnd here are the results for all Wolfram's elementary 1D CA.\n\n\n::: {.cell hash='fig8-01-1d-ca_cache/html/unnamed-chunk-3_f55fc4364929145c4bce690a84762108'}\n\n```{.r .cell-code}\n# convenience function to return a dataframe instead of a matrix\nget_df <- function(rule, n = 64, density = 0.5, t = 192) {\n  one_d_ca(rule = rule, n = n, density = density, t = t) %>%\n  reshape2::melt(c(\"t\", \"x\"), value.name = \"state\") %>%\n  mutate(state = as.logical(state),\n         rule = rule)\n}\n\n# The 32 rules that match Wolfram's selection criteria\nrules <- c(  0,   4,  18,  22,  32,  36,  50,  54,\n            72,  76,  90,  94, 104, 108, 122, 126,\n           128, 132, 146, 150, 160, 164, 178, 182,\n           200, 204, 218, 222, 232, 236, 250, 254)\n\ndf <- get_df(rules[1], t = 128)\n\nfor (rule in rules[2:32]) {\n  df <- bind_rows(df, get_df(rule, t = 128))\n}\n\n# give the rules a better label\ndf$rule <- factor(df$rule, levels = rules,\n                  labels = lapply(rules, rule_description))\n\nggplot(df) +\n  geom_raster(aes(x = t, y = x, fill = state)) + \n  scale_fill_brewer(palette = \"Paired\") +\n  coord_equal() +\n  guides(fill = \"none\") +\n  facet_wrap( ~ rule, ncol = 4) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](fig8-01-1d-ca_files/figure-html/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n::: {.cell hash='fig8-01-1d-ca_cache/html/unnamed-chunk-4_ea0bdda27f81968661ab5515b38f2bf1'}\n\n```{.r .cell-code  code-fold=\"true\"}\n# License (MIT)\n#\n# Copyright (c) 2023 David O'Sullivan\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation\n# files (the \"Software\"), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to  permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}