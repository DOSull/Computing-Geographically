{
  "hash": "4862ac665879dee2613e6707238a390a",
  "result": {
    "markdown": "---\ntitle: \"Figure 2.9 A range of spatial weights applied to polygon data\"\ncategories: \n  - figures\n  - code\n  - R\nexecute: \n  cache: true\n  freeze: auto\nknitr:\n  opts_chunk: \n    warning: false\n    message: false\n---\n\n\nThis figure is intended to demonstrate the diversity of possible conceptualisations of 'neighbour' that are often deployed in spatial analysis contexts, and represent possible different approaches to relative space. \n\nThe [`spdep` package](https://cran.r-project.org/web/packages/spdep/index.html) I am using here is not the easiest to use. The best guidance on `spdep` I've found is in \n\n> Bivand R, EJ Pebesma, and V GÃ³mez-Rubio. 2013. _Applied Spatial Data Analysis with R_. 2nd edn. Springer.\n\nThe newer [`sfdep` package](https://cran.r-project.org/package=sfdep) is still finding its feet at time of writing (Oct 2023), but will likely be a better choice before long.\n\n\n::: {.cell hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-1_a7126242f93cbb3ddb36ed9b73af8f2d'}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(spdep)\nlibrary(sp)\n```\n:::\n\n\n## Assembling the data\nFirst read a polygons dataset. You'll need to supply your own for this.\n\n\n::: {.cell hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-2_b43e4b1165e2a2961e4cee7acfdc8bf0'}\n\n```{.r .cell-code}\nchch <- st_read(\"chch-sa2.gpkg\") # you need a spatial dataset\n```\n:::\n\n\n`spdep` requires the data to be in the `sp` package format, so we convert to that.\n\n\n::: {.cell hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-3_833adbc55725f66d261d0f0732228a14'}\n\n```{.r .cell-code}\npolys <- chch %>%\n  select(geom) %>%\n  as(\"Spatial\")\n```\n:::\n\n\nNow make some points inside the polygons, and also some centroids.\n\n\n::: {.cell hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-4_6876993b4f35e63bf1830ec650bba0d5'}\n\n```{.r .cell-code}\n# guaranteed inside the polygons\npts <- chch %>%\n  st_point_on_surface() %>% \n  st_geometry()\n\n# not guaranteed, but better(?) for distance measurements\npts_c <- chch %>%\n  st_centroid() %>% \n  st_geometry()\n```\n:::\n\n\n## Maps of adjacencies based on different rules\nThese are presented in a single figure in the book in four rows of three. Here I show them as sets of three for greater clarity. \n\n### Contiguity based\n\n\n::: {.cell fig.dim='[8,3]' hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-5_9a728cf50ac07e1c44397a26dcdfb032'}\n\n```{.r .cell-code}\nlayout(matrix(1:3, ncol = 3, byrow = TRUE))\npar(mai = c(0, 0, 0.15, 0))\n\nnb <- polys %>% poly2nb(queen = TRUE)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Queen's rule adjacency\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n\nnb <- polys %>% poly2nb(queen = FALSE)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Rook's rule adjacency\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n\nnb <- nb %>% nblag(2) %>% nblag_cumul()\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Cumulative lag-2 adjacency\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](fig2-09-spatial-weights_files/figure-html/unnamed-chunk-5-1.png){width=768}\n:::\n:::\n\n\n### _k_-nearest neighbours\nNote that we use the centroids (`pts_c`) to calculate the distances, but the points inside the polygons (`pts`) from `st_point_on_surface()` for the plotting.\n\n\n::: {.cell fig.dim='[8,3]' hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-6_c6183fc85d68b4f5f00e8099e85981ee'}\n\n```{.r .cell-code}\nlayout(matrix(1:3, ncol = 3, byrow = TRUE))\npar(mai = c(0, 0, 0.15, 0))\n\nnb <- pts_c %>% knearneigh(k = 3) %>% knn2nb()\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"k = 3\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n\nnb <- pts_c %>% knearneigh(k = 6) %>% knn2nb()\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"k = 6\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n\nnb <- pts_c %>% knearneigh(k = 12) %>% knn2nb()\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"k = 12\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](fig2-09-spatial-weights_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n\n### Distance criteria\nNext, distance criteria, again calculated from centroids, but visualised using the `st_point_on_surface()`.\n\n\n::: {.cell fig.dim='[8,3]' hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-7_21a0d56a7921df830e490124a97b1b44'}\n\n```{.r .cell-code}\nlayout(matrix(1:3, ncol = 3, byrow = TRUE))\npar(mai = c(0, 0, 0.15, 0))\n\nnb <- pts_c %>% dnearneigh(d1 = 0, d2 = 1000)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Distance < 1000\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n\nnb <- pts_c %>% dnearneigh(d1 = 0, d2 = 1500)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Distance < 1500\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n\nnb <- pts_c %>% dnearneigh(d1 = 1500, d2 = 2000)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"1500 < Distance < 2000\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](fig2-09-spatial-weights_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n\n### Graph-based approaches\nFinally, some network-based possibilities, [Delaunay triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation), [Gabriel graph](https://en.wikipedia.org/wiki/Gabriel_graph) and the [relative neighbour graph](https://en.wikipedia.org/wiki/Relative_neighborhood_graph).\n\n\n::: {.cell fig.dim='[8,3]' hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-8_e35737a652d92d03bb4dbbacfd14be8b'}\n\n```{.r .cell-code}\nlayout(matrix(1:3, ncol = 3, byrow = TRUE))\npar(mai = c(0, 0, 0.15, 0))\n\ng <- tri2nb(pts_c)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Delaunay triangulation\")\nplot(g, pts, col = 'red', lwd = 0.5, add = TRUE)\n\ng <- gabrielneigh(pts_c)\nnb <- graph2nb(g)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Gabriel graph\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n\ng <- relativeneigh(pts_c)\nnb <- graph2nb(g)\nplot(polys, col = \"lightgrey\", lwd = 0.5, border = 'white', \n     main = \"Relative neighbour graph\")\nplot(nb, pts, col = 'red', lwd = 0.5, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](fig2-09-spatial-weights_files/figure-html/unnamed-chunk-8-1.png){width=768}\n:::\n:::\n\n::: {.cell hash='fig2-09-spatial-weights_cache/html/unnamed-chunk-9_8a107181da964a7394aed29aa85d26ed'}\n\n```{.r .cell-code  code-fold=\"true\"}\n# License (MIT)\n#\n# Copyright (c) 2023 David O'Sullivan\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation\n# files (the \"Software\"), to deal in the Software without restriction,\n# including without limitation the rights to use, copy, modify, merge,\n# publish, distribute, sublicense, and/or sell copies of the Software,\n# and to  permit persons to whom the Software is furnished to do so,\n# subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}